# 4. 光线追踪



计算机图形学的基本任务之一是绘制三维对象：在一个有许多三维几何物体的场景中，计算出从特定视点查看场景时对应的二维图像。这相当于几个世纪以来建筑师和工程师将他们设计的图纸展示给其他人。

从根本上说，渲染是一个输入一组物体（objects）并输出一组像素的过程。总而言之，渲染需要考虑每个物体对场景中每个像素产生的作用，渲染方式可以分为两种：一种是**物体顺序渲染**（object-order rendering），依次考虑每个物体，找到并更新该物体所影响的所有像素值。另一种是**图像顺序渲染**（image-order rendering），依次考虑每个像素，对每一像素都查找影响其取值的物体并最终计算像素值。可以从循环嵌套的角度来描述两者的区别：在基于图像顺序渲染中，“for each pixel” 循环在外部，而在基于对象顺序渲染中，“for each object”循环在外部。

按”图像顺序“和”物体顺序“的渲染器可以精确地计算渲染出相同的图像，但这两种渲染方式具有截然不同的性能特征，本书将在第9章中讨论两种方式的优缺点。一般来说，按图像顺序渲染更容易达到想要的效果并且更加灵活，但通常也需要更长的时间来生成相应的图像。

**光线追踪**（ray tracing）是一种3D场景中基于图像顺序渲染的算法。我们将首先研究光线追踪的机制，以便于我们在不了解任何应用于物体顺序渲染的数学机制的情况下，也能成功编写一个光线追踪器（ray tracer）。



## 4.1 光线追踪基础算法



光线追踪器的原理是：一次计算一个像素，对于每个像素，基本任务是找到图像中该像素位置对应的物体。每个像素“看”向不同的方向，像素看到的任何对象都必须与观测射线（*viewing ray*）相交，观测射线是一条从视点发出发并指向被观测像素的线。我们要渲染的是与观测射线相交并距离相机最近的物体，因为该物体挡住了后面所有物体的视线。找到该物体后，我们就会使用交点、表面法线和其它信息（取决于所需的渲染类型）来进行着色计算，并最终得出像素点的颜色。上述原理如图4.1所示，观测射线和T1，T2两个物体相交，但我们只对距离观测点最近的T2进行着色渲染。

<img src="4. 光线追踪.assets/image-20220911180707102.png" alt="image-20220911180707102" style="zoom: 33%;" />

<center>图4.1 光线”追踪“到场景中，第一个命中的物体就是像素看到的物体，这种情况下返回三角形T2</center>

一个基础的光线追踪器由3部分组成：

1. **光线生成**（ray generation），计算每个像素对应的观测射线的起点和方向。
2. **光线相交**（ray intersection），找到与观测射线相交的且距离观测点最近的物体。
3. **着色**（shading），根据光线相交的结果计算像素颜色。

光线追踪的基本代码结构如下：

```tex
for each pixel do
	compute viewing ray
	find first object hit by ray and its surface normal n
	set pixel color to value computed from hit point, light, and n
```

本章内容涵盖了光线生成、光线-物体求交和着色的基本方法，这些方法可以让我们实现一个简单的光线追踪器demo。但如果要开发一个更实用的图形学系统，还需要涉及第12章中提到的更高级的光线相交算法，光线追踪器的真正潜力将通过第10章中更高级的着色方法和第13章中额外的渲染技术体现出来。



## 4.2 透视



在计算机出现前的几百年里，艺术家们就已经研究了在2D画布上使用不同颜料来表现3D场景的问题，我们常见的照片也是用2D图像来展现3D场景的。从立体风格绘画到鱼眼镜头（图4.2）再到外围相机，虽然有许多非传统的方法来展现3D图像，但艺术绘画、摄影以及计算机图形学的通用方法都包括线性透视（linear perspective），在该方法中，3D物体被投影到像平面（image plane）上，真实场景中的线条就变成了图像中的线条。

<img src="4. 光线追踪.assets/image-20220912100545839.png" alt="image-20220912100545839" style="zoom: 50%;" />

<center>图4.2 用鱼眼镜头拍摄的图像不是线性透视图像</center>

最简单的投影类型是*平行投影*（*parallel projection*），即3D点沿着投影方向移动到2D平面（图4.3-4.4）。平行投影所产生的结果是由*投影方向*（*projection direction*）和像平面决定的。如果像平面垂直于观测方向，则该投影又称为*正射投影*（*orthographic*）;否则称为*斜轴投影*（*oblique*）。

<img src="4. 光线追踪.assets/image-20220912101713641.png" alt="image-20220912101713641" style="zoom: 33%;" />

<center>图4.3 当投影线互相平行且垂直于像平面时，得到的视图称为正射视图。</center>

<img src="4. 光线追踪.assets/image-20220912102122264.png" alt="image-20220912102122264" style="zoom: 33%;" />

<center>图4.4 像平面与投影方向成一定角度的平行投影称为斜轴投影(右)。在透视投影中，投影线都穿过视点，而不是互相平行的(左)。图中透视图是非斜轴投影，因为通过图像中心绘制的投影线垂直于图像平面。</center>

平行投影常用于机械和建筑制图中，因为它能使原本平行的线在投影后继续保持平行，并能保持平行于像平面的平面物体的大小和形状不变。但平行投影的优点即缺点，在我们的日常经验中，近大远小（在照片更明显），因此向远处延伸的平行线在视觉上看起来是不平行的。这是因为眼睛和相机不能从单一的观察方向收集光线，它们收集的是穿过特定视点的光。自文艺复兴以来，艺术家们就已经认识到，我们可以使用*透视投影*（*perspective projection*）绘制自然景观：沿着穿过一个点(视点)的一组线束进行投影，来替代平行的线束（图4.4），这样，距离视点较远的物体在投影时自然就变得很小。透视投影所产生的视图是由视点（而不是投影方向）和像平面决定的。与平行视图一样，根据图像中心的投影方向，透视视图也有有斜轴和正轴之分。

您可能对艺术绘画中的*三点透视*（*three-point perspective*）有所了解，这是一种手动构建透视图的方式(图4.5)。神奇的是，透视投影通过简单的数学规则就能够达到近大远小的视觉效果。

<img src="4. 光线追踪.assets/image-20220912110154889.png" alt="image-20220912110154889" style="zoom:50%;" />

<center>图4.5 在三点透视法中，艺术家选择与水平线相交的点作为“消失点”（vanishing point）。原本平行的线相交于水平线上的一点。每一组平行线都有自己的消失点。</center>



## 4.3 计算观测射线（viewing rays）



上一节中我们知道描述光线的基本要素是视点（或者平行投影的投影方向）和像平面。目前有许多方法来描述相机几何相关细节，在本节中，我们将介绍一个基于标准正交基的方法来描述观测射线，它可以用于正轴和斜轴下的平行视图以及正射视图。

为了计算观测射线，我们需要首先了解光线的数学描述。在数学上，一条光线可以用一个原点和一个传播方向来表示，3D空间下的射线则很适用于描述光线。如2.5.7节所述，人眼 **e** 到图像平面上 **s** 点的三维参数化射线（图4.6）可以表示为：
$$
\pmb{p}(t)=\pmb{e}+t(\pmb{s}-\pmb{e})
$$
<img src="4. 光线追踪.assets/image-20220912115508122.png" alt="image-20220912115508122" style="zoom:50%;" />

<center>图4.6 从眼睛到像平面上一点的光线</center>

上述公式可以这样理解：我们从**e**沿着向量(**s**−**e**)行进一段距离t，以找到点p。给定t，我们可以确定一个点**p**，点**e**是射线的原点，**s** - **e**是射线的方向。

可以注意到**p**(0) = **e**，**p**(1) = **s**；如果0 < t1 < t2，那么**p**(t1)比**p**(t2)更靠近我们的眼睛；如果t < 0，那么**p**(t)在我们的眼睛”后面“。后面我们寻找光线照射到的离眼睛最近的物体时，会用到这些特性。

在代码中，可以使用包含起点和方向的结构或对象来表示光线。例如在面向对象的编程语言中，我们可以这样表示：

```c++
class Ray
	Vec3 o | ray origin
	Vec3 d | ray direction
	Vec3 evaluate(real t) 
       return o + td
```

上面代码中我们假设*Vec3*是一个表示三维向量的类，并且支持向量的计算法则。

计算观测射线时，我们需要知道**e**(已经给出)和**s**。找到**s**看似很难，但如果我们在坐标系中解决这个问题，实际上是很简单的 。

所有光线的描述都基于一个正交直角坐标系，即相机坐标系（*camera frame*）。如图4.7所示，我们用**e**表示视点（眼睛所在位置），以视点为原点，用 **u**、**v**和 **w** 三个基向量表示坐标轴，其中**u**指向相机右方(相机所看的方向为正前方)，**v**指向上方，**w**指向后方，这样 {**u, v, w**} 就形成了一个右手坐标系。构造相机坐标系的常用方法是以**e**为视点，相机的观测方向为-**w**，上方是**v**；基于过**w**和**v**，使用2.4.7所描述的由两个向量构建正交基的方法，进而得到**u**（图4.8）。



<img src="4. 光线追踪.assets/image-20220912121700718.png" alt="image-20220912121700718" style="zoom:50%;" />

<center>图4.7 屏幕上的示例点被映射到3D窗口的阵列数组。观测射线指向窗口中的每一个点。</center>

<img src="4. 光线追踪.assets/image-20220912124627949.png" alt="image-20220912124627949" style="zoom:67%;" />

<center>图4.8 相机坐标系，向量w和观测方向相反，向量v和相机正上方共面。</center>



### 4.3.1 正射视图

对于正射视图，所有的光线方向均为-**w**。对于平行投影视图，尽管没有正射视图那样的视点，我们仍然可以使用相机坐标系的原点来定义光线的起始平面。

平行投影观测射线的起点应该在点**e**和向量**u**和**v**所定义的平面上，接下来只需要知道的信息是图像应该在平面的什么位置。我们用四个数字来定义图像尺寸，即图像的四条边：l 和 r 是图像的左右边界，是从**e**沿**u**方向测量得到的；t 和 b 是图像的上下边界，是从**e**沿着**v**方向测量得到的。通常 l < 0 < r，b < 0 < t，详见图4.9。

<img src="4. 光线追踪.assets/image-20220912144111333.png" alt="image-20220912144111333" style="zoom:50%;" />

<center>图4.9 使用相机坐标系描述光线。左：在正射视图中，光线从图像平面上的像素位置开始，且所有光线方向都相同，即视图方向。右图：在透视图中，光线从视点开始，每条光线的方向由视点 e 和像素在图像平面上的位置定义。</center>

在第3.2节中，我们提到了图像中的像素坐标。为了把有$n_x×n_y $像素的图像放入大小为$(r−l) × (t−b)$的矩形中，则水平方向像素点的间隔应为$(r−l)/nx$，竖直方向像素点的间隔应为$(t−b)/ny$，且像素矩形边缘到像素点的距离为半个像素的宽度。 这意味着实际栅格图像中位置为$(i, j)$的像素在图像平面中的位置为：
$$
u = l + (r − l)(i + 0.5)/n_x,\\
v = b + (t − b)(j + 0.5)/n_y\tag{4.1}
$$
其中$(u, v)$是像素在图像平面上的位置坐标，是相对于原点**e**和基准{**u**, **v**}测得的。

在正射视图中，我们可以简单地使用像素的图像平面位置作为射线的起点，并且我们已经知道射线的方向就是视图的方向。生成正射视图观测射线的程序如下：

​	使用公式4.1计算$u$和$v$

​	ray.o ← **e** + $u$ **u** +$v$ **v**

​	ray.d ← −**w**

生成斜轴平行视图非常简单：只需要将图像平面的法线方向**w**和观测方向**d**区别开, 使用**d**替代-**w** 。当然，我们依然使用法线方向**w**来构建**u**和**v**。



### 4.3.2 透视视图

对于透视图，所有射线都有共同的原点——视点，而射线的方向是各不相同的。图像平面也不再位于**e**所在的平面，而是在**e**前方一定距离 d 处，这个距离 d 是图象平面的距离，通常被广义的称作焦距（*focal length*），这是因为 d 的设定和现实中相机的焦距的设定是一样的。每条射线的方向都是由视点位置和像素在图像平面上的位置决定的，这种情况如图4.9所示。生成透视视图的观测射线的程序和正射视图类似：

​	使用公式4.1计算$u$和$v$

​	ray.o ← **e** 

​	ray.d ← −$d$**w** + $u$**u** + $v$**v**

与平行投影视图一样，斜轴透视视图可以通过区分平面法线方向和观测方向来实现。



## 4.4 光线-物体求交



我们生成了一条射线**e** + t**d**后，接下来就需要找到 t>0 时与任何物体的第一个交点。在实践中，一个更有效的方法是，找到在区间[t0, t1]中出现在t处的射线和物体表面的第一个交点。基本的光线求交问题实在 t0=0，t1=+∞ 的范围内进行的，我们先讨论在球体和三角形上解决这一问题，后面的小节将讨论其它物体的光线求交计算。



### 4.4.1 光线-球体求交

给定射线**p**(t) = **e** + t**d**和隐式曲面函数f (**p**) = 0（见2.7.3节），求它们的交点。当射线上的点满足曲面方程时，即为所求的交点，所以计算交点就是求解如下方程：
$$
f(\pmb p(t)) = 0 或f(\pmb e+t\pmb d)=0
$$
一个中心点为$\pmb c= (x_c,y_c,z_c)$半径为R的球体可用如下公式表示：
$$
(x-x_c)^2+(y-y_c)^2+(z-z_c)^2-R^2=0
$$
或者也可以（用向量）表示为：
$$
(\pmb p-\pmb c)·(\pmb p-\pmb c)-R^2=0
$$
任何满足这个方程的点**p**都在这个球面上。如果我们把射线$\pmb p(t) = \pmb e + t\pmb d$上的点代入这个方程，我们得到一个关于t的方程，即由点在球面上得到的t值满足的约束条件为：
$$
(\pmb e+t\pmb d-\pmb c)·(\pmb e+t\pmb d-\pmb c)-R^2=0
$$
整理得到：
$$
（\pmb d·\pmb d）t^2+2\pmb d·(\pmb e-\pmb c)t+(\pmb e-\pmb c)·(\pmb e - \pmb c)-R^2=0
$$
上式中除了参数t都是已知的，可以看出这是一个典型的一元二次方程，它有如下形式：
$$
At^2+Bt+C=0
$$
关于一元二次方程的解法见2.2章节。$B^2−4AC$为判别式，它可以判断该方程有多少个解。如果判别值为负，则其平方根为虚数，直线与球面不相交。如果判别值是正的，有两个解：一个解是光线进入球体的位置，另一个解是光线离开球体的位置。如果判别值为零，射线擦过球体，刚好在一点接触它。求解上述一元二次方程可以得到：
$$
t=\frac{-\pmb d·(\pmb e-\pmb c)±\sqrt{(\pmb d·(\pmb e-\pmb c))^2-(\pmb d·\pmb d)((\pmb e-\pmb c)·(\pmb e-\pmb c)-R^2)}}{(\pmb d·\pmb d)}
$$
在实际实现中，在计算其他项之前，应该首先检查判别式的值。为了正确的找到在[t0, t1]区间内的最近的交点，需要注意三点：如果两个解中更小的解在区间内，那么更小的解是交点，否则，如果更大的解在区间内，那么更大的解是交点。否则没有交点。

如2.7.4节所述，点**p**处的法向量由梯度**n** = 2(**p** - **c**)给出，单位法向量为(**p** - **c**)/R。



### 4.4.2 光线-三角形求交

有许多计算光线和三角形交点的算法，这里我们将介绍包含三角形的参数平面的中心坐标来求交点，因为该方法除三角形顶点外，无需长期存储其它值。

为了计算一条射线与一个参数平面的交点，我们建立了一个笛卡尔坐标相关的方程组:
$$
\left.
\begin{aligned}
x_e+tx_d=f(u,v) \\
y_e+ty_d=g(u,v) \\
z_e+tz_d=h(u,v) \\
\end{aligned}
\right\}
或，\pmb e+t\pmb d=\pmb f(u,v)
$$
我们有三个方程和三个未知数(t, u和v)，所以我们可以用数值方法求解未知数。如果幸运的话，我们可以用分析的方法解决它们。

在参数曲面是平面的情况下，参数方程可以写成矢量形式，如2.7.2节所述。如果三角形的三个顶点为a b c，则光线和三角形的交点为：
$$
\pmb e+t\pmb d = \pmb a+β(\pmb b−\pmb a)+γ(\pmb c−\pmb a)\tag{4.2}
$$
三个参数为t， β和γ。交点**p**在**e** + t**d**处，如图4.10所示。同样，从2.7.2节中我们知道当且仅当β > 0， γ > 0，且β + γ < 1时，交点在三角形内部。否则，射线穿过了三角形区域的外部，并没有和三角形相交。

<img src="4. 光线追踪.assets/image-20220922104835634.png" alt="image-20220922104835634" style="zoom:50%;" />

<center>图4.10 光线在p处和包含三角形的平面相交 </center>

为了求解式(4.2)中的t、β和γ，我们将其从矢量形式展开为（x, y, z）坐标下的三个方程:
$$
x_e +tx_d =x_a +β(x_b −x_a)+γ(x_c −x_a),\\
y_e +ty_d =y_a +β(y_b −y_a)+γ(y_c −y_a),\\ z_e +tz_d =z_a +β(z_b −z_a)+γ(z_c −z_a).
$$
这三个方程可以写成标准的线性系统：
$$
\left[
 \begin{matrix}
   x_a-x_b & x_a-x_c & x_d \\
   y_a-y_b & y_a-y_c & y_d \\
   z_a-z_b & z_a-z_c & z_d
  \end{matrix}
  \right] 
  \left[
 \begin{matrix}
   β  \\
   γ\\
   t
  \end{matrix}
  \right]=\left[
 \begin{matrix}
   x_a-x_e  \\
   y_a-y_e \\
   z_a-z_e 
  \end{matrix}
  \right]
$$
使用克莱默法则求解，得到：
$$
β=
	\frac{\left|
 \begin{matrix}
   x_a-x_e & x_a-x_c & x_d \\
   y_a-y_e & y_a-y_c & y_d \\
   z_a-z_e & z_a-z_c & z_d
  \end{matrix}
  \right| }{|\pmb A|}
$$

$$
γ=
	\frac{\left|
 \begin{matrix}
   x_a-x_b & x_a-x_e & x_d \\
   y_a-y_b & y_a-y_e & y_d \\
   z_a-z_b & z_a-z_e & z_d
  \end{matrix}
  \right| }{|\pmb A|}
$$

$$
t=
	\frac{\left|
 \begin{matrix}
   x_a-x_b & x_a-x_c & x_a-x_e \\
   y_a-y_b & y_a-y_c & y_a-y_e \\
   z_a-z_b & z_a-z_c & z_a-z_e
  \end{matrix}
  \right| }{|\pmb A|}
$$

其中矩阵**A**为：
$$
\pmb A =\left[
 \begin{matrix}
   x_a-x_b & x_a-x_c & x_d \\
   y_a-y_b & y_a-y_c & y_d \\
   z_a-z_b & z_a-z_c & z_d
  \end{matrix}
  \right] 
$$
|**A**|表示**A**的行列式。3 × 3的行列式有非常高效的计算方式，观察如下线性系统的表达式：
$$
β=\frac {j(ei−hf)+k(gf −di)+l(dh−eg)}{M},\\γ=\frac {i(ak−jb)+h(jc−al)+g(bl−kc)}{M},\\t=-\frac{f(ak − jb) + e(jc − al) + d(bl − kc)}{M}.
$$
其中，M为：
$$
M =a(ei−hf)+b(gf−di)+c(dh−eg).
$$
我们可以通过重用ei−hf等表达式的数降低操作数。

光线三角形求交得到线性解的算法有一些提前终止的条件，因此，最后的函数看起来如下：

```c++
boolean raytri (ray r, vector3 a, vector3 b, vector3 c, interval [t0, t1])
compute t
if (t < t0) or (t > t1) then
return false
compute γ
if (γ < 0) or (γ > 1) then
return false
compute β
if (β < 0) or (β > 1 − γ) then
return false return true
```



### 4.4.3 光线求交程序设计

使用面向对象的思想设计光线追踪程序是一个不错的选择，设计一个父类叫做Surface，其子类有Triangle、Sphere等。任何射线可以相交的东西，包括曲面组或高效的结构表达(第12.3节)都应该是Surface的子类。然后，光线追踪程序会为整个模型调用一次Surface类，它可以透明地添加新的(曲面)对象类型和高效的(曲面表达)结构。Surface类的一个关键接口是——与射线相交的方法：

```c++
class Surface
	HitRecord hit(Ray r, real t0, real t1)
```

这里，(t0, t1)是光线起点到相交点的区间，HitRecord是一个类，它包含所有需要的曲面相交的数据:

```c++
class HitRecord
Surface s | surface that was hit
real t | coordinate of hit point along the ray Vec3 n | surface normal at the hit point
…
```

HitRecord至少要包含相交的曲面，t值，表面法线等信息，纹理坐标，斜率向量等其他信息也可以存储在里面。根据语言的不同，HitRecord可能不是从函数中直接返回，而是通过引用传递并填充。若没有交点，可以使用t =∞的命中来表示。



### 4.4.4 和一组物体求交

大多数场景都不止包含一个物体，当我们将一条光线与场景相交时，我们必须沿着光线找到与相机最近的交点。为了实现这个需求，一个简单方法是将一组物体看作是一个对象。要使射线与该对象相交，只需使射线与这组物体中的对象相交，并返回最小t值。下面的代码是用于检测$t∈[t0,t1]$内光线场景的交点：

```c++
class Group, subclass of Surface
	list-of-Surface surfaces | list of all surfaces in the group 
  HitRecord hit(Ray ray, real t0, real t1)
		HitRecord closest-hit(∞) | initialize to indicate miss 
  	for surf in surfaces do
		rec = surf.hit(ray, t0, t1) 
    if rec.t < ∞ then
			closest-hit = rec
			t1 = t 
  return closest-hit
```

注意该算法会不断的缩小t1的范围，以便surf.hit得到的表面越来越近。一旦光线-场景求交结束，我们可以渲染出如图4.11所示的图像，但是更好的视觉表现依赖于更多的视觉线索，我们将在接下来的小节描述。

<img src="4. 光线追踪.assets/image-20220922140147694.png" alt="image-20220922140147694" style="zoom:50%;" />

<center>图4.11 一个简单的场景，只有光线产生和表面相交，但没有阴影；每个像素都被设置为固定的颜色 </center>



## 4.5 着色



当我们知道了一个像素的可见表面后，就可以通过估算着色模型（*shading model*）来计算像素值。这完全取决于程序实现——方法可以是简单的启发式，也可以是复杂的基于物理的模型。完全相同的着色模型既可以用于光线追踪中（基于图像顺序的渲染，image-order rendering），也可以用于基于物体顺序的渲染（object-order rendering）中。

第5章将描述一个简单的着色模型，它适用于基本的光线追踪器，也是我们在本章中用来制作渲染图的模型。如果要渲染更逼真的物体，你可以查看第14章中讨论的模型，这些模型更符合真实表面的物理特征。本章我们将讨论光线追踪器如何计算着色的输入。



### 4.5.1 光源

为了支持着色，光线追踪程序要有一系列的光源。在第5章的着色模型中，我们需要三种光源：点光源（point lights,）——从空间中的一点发出的光源，方向光（directional lights）——从单一方向照射向场景，漫反射光（ambient lights）——提供固定大小的光照来填补阴影。在更高级的系统中，还支持其他类型的光，如区域光(area lights，场景中发光的几何图形)或环境光(environment lights，使用图像表示来自远处的光，如天空)。

从一个点光源或方向光源计算着色需要一定的几何信息，在光线追踪器中，当光线与表面相交后，我们就可以确定这四个向量：

* **着色点x**可以通过在交点的t值处计算观察光线来计算。
* **表面法线n**取决于表面的类型(球面、三角形等)，并且每个表面都需要能够计算出光线与它相交的点的法线。

* **光照方向l**是从作为着色部分的光源位置或方向计算出来的。
* **观测方向v** 恰好是观测光线的反方向，即 $v=−d/||d||$。

来自环境光源的着色要简单得多：没有l，因为光来自任何地方；着色不依赖于v，对于第5章的简单模型，它甚至不依赖于x或n。

在包含多个光源的场景中计算着色只是简单地将各个光源的作用结果相加。在一个基本的光线追踪器中，你可以简单地循环遍历所有光源。



### 4.5.2 软件实现中的着色

一个光线追踪程序通常包含一个表示光源的对象和一个表示材质的对象。各种光源可以设计为Light类的子类，它们必须包含足够的信息来描述光源。由于着色也需要相关参数来描述表面材质，我们使用Material类来封装估算着色模型所需的属性。

不同的系统采用不同的方法来拆分光线和材质之间的着色计算。一种和本章之前介绍一致的方法是使用光线来计算所有的光强值，而使用材质来计算BRDF（双向反射比分布函数）值（光源决定光照强度，材质决定反射率）。这些类的接口可能如下所示：

```c++
class Light
	Color illuminate(Ray ray, HitRecord hrec)
class Material
	Color evaluate(Vec3 l, Vec3 v, Vec3 n)
```

然后每一个表面都应该存储一个关于它材质的引用，在这一策略下，点光源光照可以使用如下方法实现：

```c++
class PointLight, subclass of Light Color I
	Vec3 p
	Color illuminate(Ray ray, HitRecord hrec)
	Vec3 x = ray.evaluate(hrec.t) real r = ∥p − x∥
		Vec3 l = (p − x)/r
		Vec3 n = hrec.normal
		Color E = max(0, n · l) I/r2
		Color k = hrec.surface.material.evaluate(l, v, n) return kE

```

这些计算是假设Color类携带颜色的RGB属性，并支持分量乘法。这种组件布局方式也适用于将漫反射光作为一种光源进行处理：

```C++
class AmbientLight,subclass of Light
    Color Ia
    Color illuminate(Ray ray,HitRecord hrec)
        Color ka=hrec.surface.material.ka
        return kaIa
```

完整计算一个光线的着色，包括求交和处理几种光源，最终形式如下：

```
function shade-ray(Ray ray,real t0, real t1)
    HitRecord rec = scene.hit(ray,t0,t1)
    if(rec.t<INF_MAX) then
        Color c=0
        for light in scene.lights do
            c += light.illuminate(ray,rec)
        return c
    else
        return background-color
```

这样的设计让材质和光源合理的分开，允许你以后添加新的类型的材质和新的类型的光源。加入纹理进一步增加了光线追踪器架构的复杂性，见11.2.5节。

从着色本身来看，这种方法让3D物体呈现的图象更加的真实，但是它并不会表现出物体间相互作用的效果。比如说如图4.12所示的两个球体都是飘在地板上方的，并没有表现出和地板作用的结果（比如阴影，投射等作用的效果）。

<img src="4. 光线追踪.assets/image-20220922165204881.png" alt="image-20220922165204881" style="zoom:50%;" />

<center>图4.12 采用第5章着色模型生成的一个简单的着色场景 </center>



### 4.5.3 阴影

当你实现了光线追踪器中的基本着色后，就很容易将点光源或方向光源产生的阴影添加到场景中了。想象自己在一个着色的表面点x上，我们看向光源，然后看到一个物体在我们和光源之间，那就说明点x在阴影中；如果这之间没有物体，那么光源就没有被遮挡，即点x在阴影之外。

如图4.13所示，光线x+tl与物体相交，所以点x在阴影中；而光线x'+tl'与物体不相交，所以x'不在阴影中。决定所处位置在阴影之内还是阴影之外的光被称作阴影光线（shadow rays），与观测光线形成区分。

<img src="4. 光线追踪.assets/image-20220922164818682.png" alt="image-20220922164818682" style="zoom:50%;" />

<center>图4.13 点x在阴影中，而点x'不在阴影中 </center>

为了将这一算法用于着色，我们在（从光源中添加着色的）代码中添加一块 if 用来判断光源是否被遮挡。使用最朴素的实现方法，阴影光线会检查t∈[0,r]的部分，但由于数值计算的不可预测性，总会导致和P所在的平面求出一个交点。为了必将这一情况的发生，我们调整这一检测的范围为t∈[ε,r] 其中ε表示一个很小的正数（图4.14）。

<img src="4. 光线追踪.assets/image-20220922173340198.png" alt="image-20220922173340198" style="zoom:50%;" />

<center>图4.14 通过在从ε开始的区间内进行测试，我们避免了数值上的误差导致射线击中p所在的表面 </center>

阴影检测可以补充到点光源的PointLight.illuminate的方法中，通过追踪阴影光并增加判断条件。

```c++
HitRecord srec = scene.hit(Ray(x,l),epsilon,r)
    if srec.t< INF_MAX then
        proceed with normal illumination calculation
    else
        return 0 | shading point is in shadow
```

对于方向光源的阴影检测也是相似的，但是我们要令 t1=∞ 而不是r，要注意对于每一个光线的流明计算都有不同的阴影光线，并且对于漫反射着色不需要阴影检测。

阴影在视觉效果的呈现上，尤其是近邻物体的描述上具有至关重要作用，如图4.15所示：

<img src="4. 光线追踪.assets/image-20220922174001464.png" alt="image-20220922174001464" style="zoom:50%;" />

<center>图4.15 同一场景下，两束点光源照射下的着色和阴影效果 </center>

### 4.5.4 镜面反射

给一个光线追踪程序添加高光反射（镜面反射）是非常容易的。镜面反射的观测方式如图4.16所示，从 e 方向看的观察者在表面看到的是 **r** 方向上的东西。

<img src="4. 光线追踪.assets/image-20220923114729694.png" alt="image-20220923114729694" style="zoom:50%;" />

<center>图4.16 当从d方向向镜面观看时，观看者看到了镜面”下面“由r方向产生的画面 </center>

向量**r**表示向量**-d**的反射，表面法线为**n**。**r**可以使用如下计算公式计算：
$$
\pmb r=\pmb d-2(\pmb d·\pmb n)\pmb n \tag{4.3}
$$
真实世界中，光照从表面反射出来时，会发生一定的能量损失，不同颜色损失不同。例如，金色比蓝色能更有效地反射黄色光线，所以反射光会在一定程度上表现出物体的颜色。这一特性可以通过在shade-ray中增加一个的递归调用来实现，在所有的光线计算结束后再考虑反射的影响。

```
color c = c + km shade-ray (  Ray(P,r).epsilon,INF_MAX )
```

在该表达式中，$k_m$（镜面反射系数）是镜面的RGB颜色。出于和阴影计算相同的原因，我们需要确保让$t_0=ε$我们不希望反射光线和生成该光线的物体相交。

递归调用的问题在于永远不会终止，比如一个光线从房间内部出发，那么它会无限生成反射光线。这一问题可以通过增加递归深度进行解决。当然如果反射光只在$km$不为0时生成，那么代码会变得更高效。

使用常数的反射系数$k_m$会让光线追踪器产生特定的外观特性（图4.17）。在真实世界中，这一系数会根据入射角的不同而不断变化。更好的模型效果见第14章。

<img src="4. 光线追踪.assets/image-20220923140442016.png" alt="image-20220923140442016" style="zoom:50%;" />

<center>图4.17 一个由着色、阴影、镜面反射共同作用渲染的场景</center>

