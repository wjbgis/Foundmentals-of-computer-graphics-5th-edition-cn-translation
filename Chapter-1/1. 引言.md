# 1. 引言



计算机图形学描述了任何使用计算机创建和处理图像的方法。本书所介绍的算法和数学工具可用于创建各种图像——惟妙惟肖的视觉效果、丰富多彩的技术插图、精美绝伦的电脑动画。计算机创建的图形、图像可以是二维或者三维的，可以完全是由计算机合成的，也可以是通过处理现有的照片生成的。本书的内容是图形、图像，尤其是三维物体和场景生成相关的数学理论和算法基础。

学习计算及图形学需要了解特定的硬件，文件格式，通常还要掌握一到两个图形学API（详见1.3节）。计算机图形学是一个快速发展的领域，相关的知识细节也在不断变化。因此，本书所述内容尽量避免依赖特定的硬件和API，鼓励读者补充和自己的软硬件环境相关的文档。由于计算机图形学拥有足够的标准术语和概念，本书中的讨论能很好地映射到大多数软硬件环境中。

本章列举了一些基本术语和一些相关历史背景，以及一些和计算及图形学相关的信息来源。



## 1.1 图形学领域



对任何学科强制分类都是不太好的，但对于计算机图形学而言，多数从业者都会认同以下主要细分领域：

* **建模**（Modeling）是一种可以在存储在计算机上的处理形状和外观属性的数学规范。例如，一个咖啡杯在计算机上被描述为一组有序的3D点，计算机存储了连接这些点的插值规则和描述光线如何与杯子相互作用的反射模型。
* **渲染**（Rendering）是一个源于艺术的词语。它用于计算机3D模型中着色图像的创建。
* **动画**（Animation）是一种通过图像序列创造运动错觉的技术。动画运用了建模和渲染，但相较于建模和渲染增加了随时间的移动效果。

除此之外还有很多其它和计算及图形学相关的领域，他们是否属于图形学的核心范畴还有待讨论。这些领域也会在本书中有所涉及，它们包括：

* **用户交互**（User interaction）处理输入设备之间的界面，如鼠标和平板电脑，应用程序，反馈给用户的图像，以及其他感官反馈。从历史上看，这一领域很大程度上与图形有关，因为图形研究人员最早接触了现在无处不在的输入/输出设备。
* **虚拟现实**(Virtual reality)试图让用户沉浸在三维虚拟世界中。这通常要求设备至少有立体图形和对头部运动的反应。真正的虚拟现实还应该提供声音和力的反馈。这一领域需要先进的3D图形及其显示技术，因此它和图形学密切相关。
* **可视化**(Visualization)是一种通过直观显示，让用户洞察复杂信息的方法。在可视化问题中经常需要解决图形相关的问题。
* **图像处理**（Image processing）是对二维图像的操作，它在视觉和图形领域都有应用。
* **三维扫描**（Three-dimensional scanning）通过测距技术创建三维模型，这种模型对创造丰富的视觉图像很有帮助，处理这样的模型通常需要用到图形学相关算法。
* **计算摄影**（Computational photography）是利用计算机图形学、计算机视觉和图像处理方法，使通过摄影捕捉物体、场景和环境的新方法成为可能。



## 1.2 主要应用



当今，几乎所有的工作在某种程度上都能用到计算机图形学，其主要应用行业如下：

* **电子游戏**越来越多的使用复杂的3D模型和渲染算法。
* **卡通动画**通常由3D模型渲染而成。许多传统的二维动画使用三维模型的背景，这样可以实现连续移动视角，无需花费创作者大量的时间。
* **视觉特效**几乎使用了所有类型的计算机图形学技术。几乎每一部现代电影都使用数字合成技术将背景与拍摄的前景分开叠加。许多电影还使用3D建模和动画来创建合成的环境、物体，甚至大多数观众永远不会怀疑角色的真实性。
* **动画电影**使用了许多视觉效果相同的技术，但不需要使得图像看起来非常逼真。
* **CAD/CAM**是计算机辅助设计和计算机辅助制造的代表性软件，它们使用计算机技术设计零件和产品，利用这些虚拟设计来指导生产制造。例如，许多机械零件是在一个三维计算机建模包中设计的，然后在计算机控制的铣削设备上自动生产。
* **仿真**可以被是作为真实的电子游戏。例如，飞行模拟器使用复杂的3D图形来模拟驾驶飞机的体验。这种模拟对安全驾驶以及丰富的场景培训(如因成本太高或太危险而无法实际创建的特定消防场景)是非常有用的。
* **医学影像**为患者提供有意义的扫描数据，例如，一个CT数据集是由一个巨大的三维矩形密度值阵列组成的。计算机图形学被用来创建着色图像，帮助医生从这些数据中提取有用的信息。
* **信息可视化**为不一定具有“自然”视觉描述的数据创建图像。例如，巧妙的绘图技术可以帮助人们看到十个不同股票的价格随时间变化的趋势。



## 1.3 图形学 API



使用图形学函数库的关键就是和图形学相关API打交道。API即应用程序接口(application program interface, API)，它是一组执行相关操作的标准函数集合，图形学API就是一系列执行图形学基本操作的函数集合，如在屏幕上绘制图像和3D表面。

每个图形学程序都需要使用两种相关的接口：用于视觉输出的图形接口(graphics API)、用于获取输入的用户界面接口（user-interface API）。目前有两种主流的图形和用户界面接口规范。第一种集成的方式，以Java为例，其中图形和用户界面工具是集成的、完全标准化的可移植包，它完全支持Java语言开发。第二种以Direct3D和OpenGL为代表，其中的绘图命令是基于某种开发语言的（如C++）,而用户界面接口则是一个独立的部分，因系统而异。在第二种规范里，即使很简单的代码，可移植性也较差；可以针对于特定系统对用户界面接口进行可移植封装。

无论你使用哪种API，基本的图形接口调用都大致相同，本书所涉及的概念都能适用。



## 1.4 图形管线



今天，每个台式电脑都拥有一个强大的图形管线。它是一个能够以透视的方式高效绘制三维基元（3D primitives）的特殊软/硬件子系统。这个系统对处理共享顶点的3D三角形进行了优化。管线的基本作用是把3D顶点的位置映射到2D屏幕上，并对这些三角形进行着色处理，以便它们看起来十分逼真，并且保证相应的前后顺序。

用正确的前后顺序绘制三角形曾经是计算机图形学中最重要的研究问题，但现在这个问题几乎都是使用z-buffer来解决的，使用一个特殊的内存缓冲区来暴力解决这个问题。

事实证明，图形管道中的几何运算几乎完全可以在一个四维空间坐标系中完成，这个四维空间坐标系是由一个传统的三维几何坐标和一个*齐次坐标*（*homogeneous* coordinate）组成，这个齐次坐标有助于生成透视视图。这些四维坐标通过4✖️4矩阵和四维向量进行运算操作。因此，图形管线包含许多处理、组合这些矩阵和向量的机制。这个四维坐标系统是计算机科学中使用的最微妙和美丽的结构之一，当然，它也是学习计算机图形学时要跨越的最大阻碍。每本图形学书籍的第一部分都会大量设计这些坐标。

三角形的数量很大程度上决定了图像的生成速度。在许多应用程序中，交互性要大于视觉效果，所以尽量减少用来表示模型的三角形数量还是很有必要的。此外，从远处观察模型所需要的三角形比在近处所需要的三角形要少。这说明可以在不同级别展示模型的不同细节（level of detial, LOD）。



## 1.5 数值问题



许多图形学程序实际上只是3D数字代码，在这样的程序中，数值的表示往往是很重要的。在过去，很难用鲁棒和可移植的方案处理这个问题，因为不同计算机内部表示数值的方式不同，更糟糕的是，它们以不同的和互不兼容的方式处理数值产生的异常。幸运的是，现代几乎所有的计算机都符合*IEEE* *浮点数* 标准(*IEEE* *floating-point* standard , 1985)。这给程序员关于如何处理某些数值提供了极大地便利。

尽管IEEE浮点数标准有许多特性在编写数值计算的代码时很有价值，但对于图形只有少数几个特性是至关重要的。首先，也是最重要的，是要理解IEEE浮点数中有三个“特殊”的实数值:

1. **无穷大（∞）**。这是一个有效数字，它大于所有其它的有效数字。
2. **负无穷大（-∞）**。这是一个有效数字，它小于所有其它的有效数字。
3. **非数值（NaN）**。这是一个无效的数字，产生于不符合逻辑的操作，例如0除以0。

IEEE浮点数的设计者们制定了一些对程序员非常友好的规范，其中许多都与上面提到的三个特殊值的异常处理有关(如除以0)。在这些情况下，会记录异常，但在许多情况下，程序员可以忽略它。具体地说，对于任意正实数a，下面涉及无限值的除法规则成立：
$$
+a/(+∞)=+0,\\
-a/(+∞)=-0,\\
+a/(−∞) = −0,\\
−a/(−∞) = +0.
$$

>IEEE浮点有两种表示0的方式，+0 和 -0，二者的区别只是偶尔才能体现，但当二者出现时还是很重要的。

其它涉及无限值得运算操作和人们预期的一样，再次以任意正实数a为例，运算遵循如下规则：
$$
∞ + ∞ = +∞,\\
∞ − ∞ = NaN,\\
∞ × ∞ = ∞,\\
∞/∞ = NaN,\\
∞/a = ∞,\\
∞/0 = ∞,\\
0/0 = NaN.
$$
布尔运算中包含无限值的规则如下：

1. 所有有限有效数组都小于+∞，
2. 所有有限有效数字都大于-∞，
3. -∞小于+∞。

包含NaN时的规则如下：

1. 任何包含NaN的算术表达式都会产生NaN，
2. 布尔运算中包含NaN时结果为false。

也许IEEE浮点标准中最有用的地方是如何处理被0做除数的问题，对于任意正实数a，以下关于0做除数的规则成立：
$$
+a/ +0 = +∞,\\ −a/ +0 = −∞.
$$
如果程序员利用IEEE规则，许多数值计算将变得更加简单。例如，考虑这样的表达式:
$$
a=\frac{1}{\frac{1}{b}+\frac{1}{c}}
$$
这个表达式出现在电阻器和透镜上。如果除以0则会导致系统崩溃（在IEEE浮点规则之前许多系统都是如此），然后就需要两个if语句检查b和c的是否为0或者很小的值。相反，如果我们使用IEEE浮点规则，当b或c为0时，则如愿得到a的值为0。另一种避免特殊检查的常见技巧是利用NaN的布尔运算规则。考虑下面的代码:

```
a = f(x)
if (a > 0) then
	do something
```

函数f可能会返回诸如∞和NaN这样的值，但if语句仍然起作用，当a=NaN或-∞时返回false，当a=+∞时返回true。这里的if语句能做出正确的判断，无需再做一些特殊判断。这使得程序体积更小、鲁棒性更好、执行效率更高。



## 1.6效率



没有什么神奇的法则能使代码运行效率更高。效率是通过仔细权衡实现的，而这些权衡对于不同架构又是不同的。然而，在可预见的将来，一个很好的启发式是程序员应该更多地关注内存访问模式，而不是操作数。这与20年前的最佳启发式相反，发生这种变化的原因是内存速度未能跟上处理器速度发展的步伐。由于这种趋势还在持续，有限和一致的内存访问对于优化的重要性越来越大。

使代码快速运行的合理方法是按照以下顺序进行，只采取那些必要的步骤:

1. 尽可能地以最直接的方式编写代码。根据需要即时计算中间的结果，而不是存储它们。
2. 在优化模式下编译代码。
3. 使用任何现有的分析工具找到代码的瓶颈。
4. 检查数据结构以寻找改善局部代码性能的方法。如果可能，让数据单元大小与目标架构上的缓存/页面大小匹配。
5. 如果分析揭示了数值计算中的瓶颈，请检查编译器生成的汇编代码，以查找遗漏的效率提升点。重写源代码以解决您发现的任何问题。

上述步骤最重要的是第一步。大多数“优化”并没有提升效率反而使代码更难阅读。此外，花在代码优化上的时间更适合用来排查bug和添加新功能。还有，要谨慎对待旧文档的一些建议；有一些经典的代码技巧，例如使用整数而不是实数，可能不再带来效率上的提升，因为现代cpu执行浮点运算的速度通常与执行整数运算的速度一样快。在所有情况下，都需要进行分析，以确保针对特定机器和编译器的任何优化所带来的好处。



## 1.7 设计和编写图形学程序



某些常见的策略在图形编程中通常很实用。在本节中，我们将提供一些建议，您在实现本书中学习的方法时会发现这些建议很有帮助。

### 1.7.1 类的设计

对任何图形学程序而言，其关键部分都是为几何（geometry）实体(如向量和矩阵)以及图形（graphic）实体(如RGB颜色和图像)提供良好的类或程序。这些程序应该尽可能设计的简洁高效。一个常见的设计问题是：位置和位移是否应该被设计为单独的类，因为它们有不同的操作；例如，一个位置乘以二分之一没有任何几何意义，而位移却有意义（Goldman, 1985; DeRose, 1989）。业内在这个问题上基本没有达成一致，这可能会在图形从业者中引发数小时的激烈辩论，但为了举例，我们假设不做这种区分。

这意味着我们要编写一些基本的类：

* **vector2**.   2D向量类，储存一个x分量和一个y分量。它应该将这些分量储存在一个长度为2的数组中，以便支持索引操作。还应该支持向量的加法、减法、点积、叉积、标量乘法和标量除法。
* **vector3** . 3D向量类，和2D向量类似。
* **hvector**.  齐次坐标向量，由4个分量组成（详见第8章）。
* **rgb**.  存储三个分量的RGB颜色。还应该包括RGB加法、RGB减法、RGB乘法、标量乘法和标量除法的操作。
* **transform**.  一个4 × 4的变换矩阵。应该包含一个矩阵乘法和用于位置、方向和表面法向量的成员函数。如第7章所示，这些都是不同的。
* **image**.  一个具有输出操作的RGB像素组成的二维阵列。

此外，你可能也可能不想为区间、标准正交基和坐标框架添加相应的类。

### 1.7.2 Float vs. Double

现代计算机架构表明，保持低内存使用和保持一致的内存访问是提升效率的关键。这建议使用单精度数据。然而为了避免数值问题，建议采用双精度算法。这种权衡取决于你的程序，但是最好在类定义中有一个默认值。

>我建议在几何计算式使用double，在颜色计算中使用float。对于占用大量内存的数据，如三角网格，我建议存储float数据，但在通过成员函数访问数据时，要转为double。— P.S.

### 1.7.3 调试图形学程序

如果你询问周围的人，会发现经验越丰富的程序员使用传统调试器的的频率越低。这种现象的原因之一是：相对于简单程序，在复杂的程序中使用传统调试器很不方便。另一个原因是，最难发现错误是概念性错误，即执行了错误的内容，并且很容易浪费大量时间在变量值上，而没有发现错误。我们发现了几种调试策略在图形学代码中非常有用：

#### 科学方法

在图形学程序中有一种非常有用的替代传统方式的调试方法。它的缺点是：去做程序员在他们职业生涯早期被教导不要做的事。你可能会感到“顽皮”：我们创建一个图像并去观察它的问题所在。然后，我们对导致问题的原因提出一个假设并对其进行验证。例如，在光线追踪程序中，我们可能会有许多看起来有点随机的暗色像素。这就是多数人在写射线追踪器时遇到的典型的“阴影痤疮”（shadow acne）问题。传统的调试在这里没有太大作用；相反，我们必须意识到阴影光线照射到被着色的表面。我们可能会注意到，黑点的颜色是环境色，所以缺少的是直射光照。在阴影中可以关闭直射光照，所以你可能会假设这些暗色点被错误地标记为阴影，而实际上它们并不是。为了验证这个假设，我们可以关闭阴影检查并重新编译。这将表明这些是错误的阴影测试，我们可以继续我们的检测工作。这种方法有时可以成为很好的实践的原因是，我们从来不需要发现一个错误的值，或者真正确定我们的概念错误。相反，我们只是通过实验缩小了我们的概念性错误。通常情况下，只需要进行几次验证就可以跟踪到问题，而且这样的调试是令人开心的。

#### 作为编码调试输出图像

在很多情况下，从图形程序中获得调试信息的最简单方式是将图像输出。如果你想知道某个变量在像素上的部分计算值，你可以临时修改代码，把这个值直接赋给输出的图像，从而跳过通常要进行的其它计算。例如，如果你怀疑表面法线导致了阴影问题，你可以直接将法线复制到图像上（x转为红色，y转为绿色，z转为蓝色），结果就是是在你的计算中实际使用的矢量彩色编码图。或者，如果你怀疑某个特定值超出了它的有效取值范围，可以让你的代码在发生这种情况的地方写上亮红色的像素。其它常见技巧包括用明显的颜色绘制表面的背面(当它们不应该是可见的时候)，用物体的ID号给图像着色，或者用像素的计算量来着色。

#### 使用调试器

还有一些情况，特别是当上述科学方法似乎已经导致了矛盾的时候，当通过观察以无法发现问题的时候。困难在于图形学程序经常涉及到很多很多相同代码的执行(例如，每个像素执行一次，或者每个三角形执行一次)，这使得从一开始就在调试器中逐步执行是完全不切实际的。而最困难的bug通常只出现在复杂的输入中。

一个好用的方法是：为这个bug设置一个“陷阱”。确保你的程序是确定性的 ——在单一线程中运行，并确保所有的随机数都是由固定的种子计算出来的。然后，找到出现问题的像素或三角形，并在你怀疑有问题的代码前加一条语句，只执行可疑情况。例如，你发现像素（126,247）出现了问题，那么可以添加：

```
if x = 126 and y = 247 then
print "blarg!"
```

如果你在打印语句上设置一个断点，就可以在计算感兴趣的像素之前进入调试器。一些调试器具有“条件断点”特性，可以在不修改代码的情况下实现相同的功能。

在程序发生崩溃的情况下，传统的调试器对于确定崩溃的位置十分有用。你应该回溯代码，使用断言并重新编译，以找到代码出错的地方。这些断言应该保留在代码中，以防将来可能出现的bug。这又意味着避免了传统的单步调试，因为这不会在你的程序中加入价值的断言。

#### 调试数据可视化

通常我们很难理解程序正在做什么，因为它在最终报错之前计算了很多中间结果。这种情况类似于需要观测大量数据的科学实验一样，它们有一个相同解决方案：生成便于理解不同数据的含义的图表。例如，在光线追踪中，你可能会写代码将光线可视化，这样就可以清晰地看到哪些路径对像素产生了影响，或者在一个图像采样程序中，你可以做一些图像来显示所有从输入中提取的样本点。在编写可视化程序内部状态的代码上花点时间，在程序优化时有助于更好地理解程序的行为。



## 说明

上述关于软件工程的论述参考了 *Effective C++* se- ries (Meyers, 1995, 1997), the *Extreme Programming* movement (Beck & Andres, 2004), 和 *The Practice of Programming* (Kernighan & Pike, 1999) 。关于实验性调试的介绍和Steve Parker共同讨论后而总结的。

有许多和计算机图形学相关的年会，包括 ACM SIGGRAPH and SIGGRAPH Asia, Graphics Interface, the Game Developers Conference (GDC), Eurographics, Pacific Graphics, High Performance Graphics, the Eurographics Symposium on Rendering, 以及 IEEE VisWeek. 网上搜索很容易找到这些会议。